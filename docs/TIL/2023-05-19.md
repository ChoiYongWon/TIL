# 2023-05-19

## Git Grep

```sh
git grep <문자열 및 정규표현식>
```

워킹 디렉토리에 추적하고 있는 파일이나, Tree 객체에 존재하는 Blob 객체내의 내용을 문자열이나 정규표현식을 이용해 찾을 수 있음.
대상을 지정하지 않으면 워킹 디렉토리를 기준으로 검색한다.

> git add 를 하는 순간 blob 객체가 생성된다

```sh
git grep <문자열 및 정규표현식> <COMMIT_ID>
```

위와 같이 특정 커밋 객체를 대상으로 조회할 수 있다.

### -n --line-number

문자열이 위치한 라인번호도 함께 출력된다.

```sh
$ git grep -n gmtime_r
compat/gmtime.c:3:#undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:482:             if (gmtime_r(&now, &now_tm))
date.c:545:             if (gmtime_r(&time, tm)) {
date.c:758:             /* gmtime_r() in match_digit() may have clobbered it */
git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);
git-compat-util.h:1140:#define gmtime_r git_gmtime_r
```

### -c --count

결과 대신 어떤 파일에서 몇 개나 찾았는지 출력

```sh
$ git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:3
git-compat-util.h:2
```

### -p --show-function

매칭되는 라인이 있는 함수나 메서드도 함께 출력

```sh
$ git grep -p gmtime_r *.c
date.c=static int match_multi_number(timestamp_t num, char c, const char *date,
date.c:         if (gmtime_r(&now, &now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&time, tm)) {
date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
date.c:         /* gmtime_r() in match_digit() may have clobbered it */
```

gmtime_r 함수를 `int match_multi_number` 함수와 `int match_digit` 함수에서 호출하고 있다는 걸 확인할 수 있다.

## Git 커밋 히스토리 단장하기

리모트 브랜치로 푸쉬하기 전 로컬 히스토리를 수정해야 할 때가 있다.

- 커밋 메세지 및 내용 변경
- 커밋 순서 변경
- 여러개의 커밋을 하나로 병합
- 하나의 커밋을 여러개로 분리
- 커밋 삭제

`이 모든 과정은 다른 사람과 코드를 공유하기 전에 해야 한다.`

### 마지막 커밋 수정

```sh
$ git commit --amend
```

이 명령은 자동으로 텍스트 편집기를 실행시켜 마지막 커밋 메시지를 열어주고 커밋 메시지를 수정해서 저장하면 마지막 커밋 메시지가 수정된다.

`git add .` 를 한 상태에서 실행하면 바뀐 내용까지 함께 반영된다.

해당 명령어를 수행하면 Commit SHA-1 값이 바뀐다.

### 커밋 메시지 여러개 수정

```sh
$ git rebase -i <COMMIT_ID>
```

이 명령을 이용하여 예전 커밋을 수정할 수 있다.  
이전에 rebase 명령은 특정 브랜치의 변경사항을 patch로 생성하여 현재 브랜치에 적용한다. git rebase 명령에 -i COMMIT ID를 입력하면 해당 COMMIT ID를 포함한 커밋목록이 첨부된 스크립트를 텍스트 편집기로 열어준다.
커밋 목록은 다음과 같은 형식이다

> COMMAND COMMIT_ID COMMIT_MESSAGE

```sh
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

위에서 아래로 각각의 커밋에 COMMAND를 수행한다.
즉, 가장 위의 커밋이 가장 오래된 커밋이다.

COMMAND의 기능은 다음과 같다.

| COMMAND | 단축어 | 가능                                                  |
| ------- | ------ | ----------------------------------------------------- |
| pick    | p      | 커밋을 사용한다.                                      |
| reword  | r      | 커밋을 사용하고, 커밋 메시지만 수정                   |
| edit    | e      | 커밋을 사용하고, 커밋 자체 수정                       |
| squash  | s      | 커밋을 사용하고, 이전 커밋 병합                       |
| fixup   | f      | 커밋을 사용하고, 이전 커밋 병합, 커밋 메시지는 병합 X |
| exec    | x      | 커밋이 적용된 후 실행할 Shell 명령어를 지정           |

COMMAND를 입력한 후 텍스트 파일을 저장하면
각 커밋메시지가 해당 COMMAND를 수행한다. pick를 제외한 COMMAND는 일종의 Breakpoint 역할을 한다.

각 Breakpoint에서 작업을 수행 후 `git rebase --continue` 명령을 통해 다음 Breakpoint로 넘어갈 수 있다.

### 커밋 순서 바꾸기

git rebase -i HEAD~3을 입력하면 다음과 같은 커밋목록이 나타난다.

```sh
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

아래와 같이 수정한다.

```sh
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
```

수정한 내용을 저장하고 편집기를 종료하면 git은 젤 수정목록의 젤 오래된 커밋의 부모 커밋으로 이동하여 `310154e`와 `f7f3f6d`를 순서대로 적용한다.

### 커밋 분리하기

기존 하나의 커밋을 여러개로 분리하는 과정이다.  
마찬가지로 git rebase -i 명령어에서 분리할 커밋의 COMMAND를 edit으로 변경한다.

```sh
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

저장하면 git은 `f7f3f6d`를 처리하고 `310154e`에서 Breakpoint가 걸린다.
해당 커밋 시점에서 작업할 수 있는 환경이 생성된다.

여기서 커밋을 해제하는 git reset HEAD^ 명령어로 커밋을 해제한다.  
그러면 수정했던 파일은 다 Unstaged 상태가 된다.

사용자는 git add와 commit 과정을 반복하여 여러개의 커밋을 생성한 후 `git rebase --continue` 명령을 실행하면 된다.

```sh
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
```
